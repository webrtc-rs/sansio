//! # Protocol Trait - Sans-IO Protocol Abstraction
//!
//! The [`Protocol`] trait provides a simplified, Sans-IO interface for building network protocols.
//! It's fully decoupled from I/O operations, making protocols easy to test, compose, and reuse.
//!
//! ## Overview
//!
//! The Protocol trait defines a push-pull API for handling messages:
//! - **Push API** (`handle_*`): Push data/events into the protocol
//! - **Pull API** (`poll_*`): Poll results from the protocol
//!
//! This design allows you to:
//! - Test protocol logic without real I/O
//! - Run protocols in any environment (sync, async, embedded)
//! - Compose multiple protocol layers
//!
//! ## Type Parameters
//!
//! - `Rin`: Input read message type (what you push in for reading)
//! - `Win`: Input write message type (what you push in for writing)
//! - `Ein`: Input event type (custom events specific to your protocol)
//!
//! ## Associated Types
//!
//! - `Rout`: Output read message type (what you poll after reading)
//! - `Wout`: Output write message type (what you poll after writing)
//! - `Eout`: Output event type (events generated by the protocol)
//! - `Error`: Error type for operations
//!
//! ## Example
//!
//! ```rust
//! use sansio::Protocol;
//! use std::time::Instant;
//! use std::collections::VecDeque;
//!
//! # #[derive(Debug)]
//! # struct MyError;
//! # impl std::fmt::Display for MyError {
//! #     fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
//! #         write!(f, "MyError")
//! #     }
//! # }
//! # impl std::error::Error for MyError {}
//! #
//! /// A simple uppercase protocol: converts incoming strings to uppercase
//! struct UppercaseProtocol {
//!     output_queue: VecDeque<String>,
//! }
//!
//! impl UppercaseProtocol {
//!     fn new() -> Self {
//!         Self {
//!             output_queue: VecDeque::new(),
//!         }
//!     }
//! }
//!
//! impl Protocol<String, String, ()> for UppercaseProtocol {
//!     type Rout = String;
//!     type Wout = String;
//!     type Eout = ();
//!     type Error = MyError;
//!
//!     fn handle_read(&mut self, msg: String) -> Result<(), Self::Error> {
//!         // Process incoming message
//!         self.output_queue.push_back(msg.to_uppercase());
//!         Ok(())
//!     }
//!
//!     fn poll_read(&mut self) -> Option<Self::Rout> {
//!         // Return processed message
//!         self.output_queue.pop_front()
//!     }
//!
//!     fn handle_write(&mut self, msg: String) -> Result<(), Self::Error> {
//!         // For this simple protocol, just pass through
//!         self.output_queue.push_back(msg);
//!         Ok(())
//!     }
//!
//!     fn poll_write(&mut self) -> Option<Self::Wout> {
//!         self.output_queue.pop_front()
//!     }
//! }
//!
//! // Usage
//! let mut protocol = UppercaseProtocol::new();
//!
//! // Push data in
//! protocol.handle_read("hello".to_string()).unwrap();
//!
//! // Pull results out
//! assert_eq!(protocol.poll_read(), Some("HELLO".to_string()));
//! ```
//!
//! ## Comparison with Handler
//!
//! The [`Protocol`] trait is simpler than [`Handler`](crate::Handler):
//!
//! | Feature | Protocol | Handler |
//! |---------|----------|---------|
//! | Complexity | Simple | More complex |
//! | Context | No context object | Has context |
//! | Composition | Manual | Pipeline |
//! | Best for | Single protocols | Protocol stacks |
//!
//! Use `Protocol` when you want a simple, self-contained protocol.
//! Use `Handler` when building complex protocol pipelines.

use std::time::Instant;

/// A Sans-IO protocol abstraction.
///
/// The `Protocol` trait provides a simplified interface for building network protocols
/// that are fully decoupled from I/O operations.
///
/// # Type Parameters
///
/// - `Rin`: Input read message type
/// - `Win`: Input write message type
/// - `Ein`: Input event type
///
/// # Design Pattern
///
/// This trait follows a push-pull pattern:
/// 1. **Push** data/events into the protocol using `handle_*` methods
/// 2. **Pull** results from the protocol using `poll_*` methods
///
/// This allows the protocol logic to be completely independent of I/O,
/// making it easy to test and reuse in different contexts.
///
/// # Example
///
/// See the [module-level documentation](index.html) for a complete example.
pub trait Protocol<Rin, Win, Ein> {
    /// Output read message type
    ///
    /// This is the type of messages produced after processing inbound data.
    type Rout;

    /// Output write message type
    ///
    /// This is the type of messages produced for outbound transmission.
    type Wout;

    /// Output event type
    ///
    /// Custom events that the protocol may generate.
    type Eout;

    /// Error type for protocol operations
    type Error;

    /// Handle an incoming read message.
    ///
    /// Processes an inbound message. The result can be polled later via [`poll_read`].
    ///
    /// # Parameters
    ///
    /// - `msg`: The incoming message to process
    ///
    /// # Returns
    ///
    /// - `Ok(())` if the message was successfully queued for processing
    /// - `Err(Self::Error)` if processing failed
    ///
    /// # Example
    ///
    /// ```ignore
    /// protocol.handle_read(incoming_data)?;
    /// // Later...
    /// if let Some(processed) = protocol.poll_read() {
    ///     // Handle processed data
    /// }
    /// ```
    ///
    /// [`poll_read`]: Protocol::poll_read
    fn handle_read(&mut self, msg: Rin) -> Result<(), Self::Error>;

    /// Poll for a processed read message.
    ///
    /// Returns the next processed inbound message, if any.
    /// Call this after [`handle_read`] to retrieve processed results.
    ///
    /// # Returns
    ///
    /// - `Some(Rout)` if a processed message is available
    /// - `None` if no processed messages are ready
    ///
    /// [`handle_read`]: Protocol::handle_read
    fn poll_read(&mut self) -> Option<Self::Rout>;

    /// Handle an outgoing write message.
    ///
    /// Processes an outbound message for transmission. The result can be polled
    /// later via [`poll_write`].
    ///
    /// # Parameters
    ///
    /// - `msg`: The outgoing message to process
    ///
    /// # Returns
    ///
    /// - `Ok(())` if the message was successfully queued
    /// - `Err(Self::Error)` if processing failed
    ///
    /// [`poll_write`]: Protocol::poll_write
    fn handle_write(&mut self, msg: Win) -> Result<(), Self::Error>;

    /// Poll for a processed write message.
    ///
    /// Returns the next processed outbound message, if any.
    /// Call this after [`handle_write`] to retrieve messages ready for transmission.
    ///
    /// # Returns
    ///
    /// - `Some(Wout)` if a message is ready to send
    /// - `None` if no messages are ready
    ///
    /// [`handle_write`]: Protocol::handle_write
    fn poll_write(&mut self) -> Option<Self::Wout>;

    /// Handle a custom event.
    ///
    /// Process protocol-specific events. The default implementation does nothing.
    ///
    /// # Parameters
    ///
    /// - `_evt`: The event to handle
    ///
    /// # Returns
    ///
    /// - `Ok(())` by default
    /// - Override to provide custom event handling logic
    fn handle_event(&mut self, _evt: Ein) -> Result<(), Self::Error> {
        Ok(())
    }

    /// Poll for a generated event.
    ///
    /// Returns the next event generated by the protocol, if any.
    ///
    /// # Returns
    ///
    /// - `Some(Eout)` if an event was generated
    /// - `None` by default (override to implement custom events)
    fn poll_event(&mut self) -> Option<Self::Eout> {
        None
    }

    /// Handle a timeout event.
    ///
    /// Called periodically to allow the protocol to perform time-based operations
    /// (e.g., heartbeats, timeouts, retransmissions).
    ///
    /// # Parameters
    ///
    /// - `_now`: The current timestamp
    ///
    /// # Returns
    ///
    /// - `Ok(())` by default
    /// - Override to implement time-based protocol logic
    fn handle_timeout(&mut self, _now: Instant) -> Result<(), Self::Error> {
        Ok(())
    }

    /// Poll for the next timeout deadline.
    ///
    /// Returns when the protocol next wants to be called via [`handle_timeout`].
    ///
    /// # Returns
    ///
    /// - `Some(Instant)` if the protocol has a pending timeout
    /// - `None` if no timeout is needed (default)
    ///
    /// # Example
    ///
    /// ```ignore
    /// if let Some(deadline) = protocol.poll_timeout() {
    ///     // Wait until deadline, then call protocol.handle_timeout(now)
    /// }
    /// ```
    ///
    /// [`handle_timeout`]: Protocol::handle_timeout
    fn poll_timeout(&mut self) -> Option<Instant> {
        None
    }

    /// Close the protocol.
    ///
    /// Called when the protocol should perform cleanup and release resources.
    ///
    /// # Returns
    ///
    /// - `Ok(())` by default
    /// - Override to implement cleanup logic
    fn close(&mut self) -> Result<(), Self::Error> {
        Ok(())
    }
}

// ========================================
// Blanket Implementations
// ========================================

/// Blanket implementation for mutable references.
///
/// This allows protocols to be used through mutable references without
/// requiring explicit dereferencing.
impl<P, Rin, Win, Ein> Protocol<Rin, Win, Ein> for &mut P
where
    P: Protocol<Rin, Win, Ein> + ?Sized,
{
    type Rout = P::Rout;
    type Wout = P::Wout;
    type Eout = P::Eout;
    type Error = P::Error;

    fn handle_read(&mut self, msg: Rin) -> Result<(), P::Error> {
        (**self).handle_read(msg)
    }

    fn poll_read(&mut self) -> Option<P::Rout> {
        (**self).poll_read()
    }

    fn handle_write(&mut self, msg: Win) -> Result<(), P::Error> {
        (**self).handle_write(msg)
    }

    fn poll_write(&mut self) -> Option<P::Wout> {
        (**self).poll_write()
    }

    fn handle_event(&mut self, evt: Ein) -> Result<(), P::Error> {
        (**self).handle_event(evt)
    }

    fn poll_event(&mut self) -> Option<P::Eout> {
        (**self).poll_event()
    }

    fn handle_timeout(&mut self, now: Instant) -> Result<(), P::Error> {
        (**self).handle_timeout(now)
    }

    fn poll_timeout(&mut self) -> Option<Instant> {
        (**self).poll_timeout()
    }

    fn close(&mut self) -> Result<(), P::Error> {
        (**self).close()
    }
}

/// Blanket implementation for boxed protocols.
///
/// This allows protocols to be used through `Box<dyn Protocol>` for dynamic dispatch.
impl<P, Rin, Win, Ein> Protocol<Rin, Win, Ein> for Box<P>
where
    P: Protocol<Rin, Win, Ein> + ?Sized,
{
    type Rout = P::Rout;
    type Wout = P::Wout;
    type Eout = P::Eout;
    type Error = P::Error;

    fn handle_read(&mut self, msg: Rin) -> Result<(), P::Error> {
        (**self).handle_read(msg)
    }

    fn poll_read(&mut self) -> Option<P::Rout> {
        (**self).poll_read()
    }

    fn handle_write(&mut self, msg: Win) -> Result<(), P::Error> {
        (**self).handle_write(msg)
    }

    fn poll_write(&mut self) -> Option<P::Wout> {
        (**self).poll_write()
    }

    fn handle_event(&mut self, evt: Ein) -> Result<(), P::Error> {
        (**self).handle_event(evt)
    }

    fn poll_event(&mut self) -> Option<P::Eout> {
        (**self).poll_event()
    }

    fn handle_timeout(&mut self, now: Instant) -> Result<(), P::Error> {
        (**self).handle_timeout(now)
    }

    fn poll_timeout(&mut self) -> Option<Instant> {
        (**self).poll_timeout()
    }

    fn close(&mut self) -> Result<(), P::Error> {
        (**self).close()
    }
}
