//! # Sans-IO Protocol Framework
//!
//! A lightweight, zero-dependency framework for building protocol implementations that are
//! completely decoupled from I/O operations.
//!
//! ## What is Sans-IO?
//!
//! Sans-IO (French for "without I/O") is an architectural pattern that separates protocol logic
//! from I/O handling. This separation provides several key benefits:
//!
//! - **Testability**: Protocol logic can be tested without mocking sockets or async runtimes
//! - **Portability**: Same protocol works in sync, async, embedded, or WASM environments
//! - **Composability**: Multiple protocol layers can be easily stacked and combined
//! - **Debuggability**: State machines can be inspected without I/O side effects
//!
//! ## no_std Support
//!
//! This crate is `no_std` by default and works in any environment - embedded systems,
//! WASM, or standard applications.
//!
//! ### Time Handling
//!
//! The `Time` associated type is fully generic, allowing you to use any time representation:
//!
//! - **With std**: Use `std::time::Instant` or `std::time::SystemTime`
//! - **Embedded/bare-metal**: Use `u64` for tick counts, `i64` for milliseconds, or custom time types
//! - **No timeouts**: Use `()` (unit type) when timeout handling isn't needed
//!
//! This flexibility means timeout functionality works everywhere - you just choose the
//! appropriate time type for your platform.
//!
//! ## The Protocol Trait
//!
//! The [`Protocol`] trait provides a push-pull API for handling messages:
//!
//! - **Push API** (`handle_*`): Push data/events into the protocol
//! - **Pull API** (`poll_*`): Poll results from the protocol
//!
//! This design enables complete I/O independence while maintaining a clean, intuitive interface.
//!
//! ### Type Parameters
//!
//! - `Rin`: Input read message type (what you push in for reading)
//! - `Win`: Input write message type (what you push in for writing)
//! - `Ein`: Input event type (custom events specific to your protocol)
//!
//! ### Associated Types
//!
//! - `Rout`: Output read message type (what you poll after reading)
//! - `Wout`: Output write message type (what you poll after writing)
//! - `Eout`: Output event type (events generated by the protocol)
//! - `Error`: Error type for operations
//!
//! ## Basic Example
//!
//! ```rust
//! use sansio::Protocol;
//! # extern crate std;
//! # use std::collections::VecDeque;
//!
//! # #[derive(Debug)]
//! # struct MyError;
//! # impl std::fmt::Display for MyError {
//! #     fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
//! #         write!(f, "MyError")
//! #     }
//! # }
//! # impl std::error::Error for MyError {}
//! #
//! /// A simple uppercase protocol: converts incoming strings to uppercase
//! struct UppercaseProtocol {
//!     routs: VecDeque<String>,
//!     wouts: VecDeque<String>,
//! }
//!
//! impl UppercaseProtocol {
//!     fn new() -> Self {
//!         Self {
//!             routs: VecDeque::new(),
//!             wouts: VecDeque::new(),
//!         }
//!     }
//! }
//!
//! impl Protocol<String, String, ()> for UppercaseProtocol {
//!     type Rout = String;
//!     type Wout = String;
//!     type Eout = ();
//!     type Error = MyError;
//!     type Time = ();  // No timeout handling needed
//!
//!     fn handle_read(&mut self, msg: String) -> Result<(), Self::Error> {
//!         // Process incoming message
//!         self.routs.push_back(msg.to_uppercase());
//!         Ok(())
//!     }
//!
//!     fn poll_read(&mut self) -> Option<Self::Rout> {
//!         // Return processed message
//!         self.routs.pop_front()
//!     }
//!
//!     fn handle_write(&mut self, msg: String) -> Result<(), Self::Error> {
//!         // For this simple protocol, just pass through
//!         self.wouts.push_back(msg);
//!         Ok(())
//!     }
//!
//!     fn poll_write(&mut self) -> Option<Self::Wout> {
//!         self.wouts.pop_front()
//!     }
//! }
//!
//! // Usage
//! let mut protocol = UppercaseProtocol::new();
//!
//! // Push data in
//! protocol.handle_read("hello".to_string()).unwrap();
//!
//! // Pull results out
//! assert_eq!(protocol.poll_read(), Some("HELLO".to_string()));
//! ```
//!
//! ## Timeout Handling Example
//!
//! Protocols can handle time-based operations like heartbeats or retransmissions.
//!
//! ### Using std::time::Instant
//!
//! ```rust
//! # extern crate std;
//! use sansio::Protocol;
//! use std::time::{Duration, Instant};
//!
//! # #[derive(Debug)]
//! # struct MyError;
//! # impl std::fmt::Display for MyError {
//! #     fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
//! #         write!(f, "MyError")
//! #     }
//! # }
//! # impl std::error::Error for MyError {}
//! #
//! /// A protocol that sends periodic heartbeats
//! struct HeartbeatProtocol {
//!     next_heartbeat: Option<Instant>,
//!     heartbeat_interval: Duration,
//!     pending_write: Option<Vec<u8>>,
//! }
//!
//! impl HeartbeatProtocol {
//!     fn new(interval: Duration) -> Self {
//!         Self {
//!             next_heartbeat: None,
//!             heartbeat_interval: interval,
//!             pending_write: None,
//!         }
//!     }
//! }
//!
//! impl Protocol<Vec<u8>, Vec<u8>, ()> for HeartbeatProtocol {
//!     type Rout = Vec<u8>;
//!     type Wout = Vec<u8>;
//!     type Eout = ();
//!     type Error = MyError;
//!     type Time = Instant;  // Using std::time::Instant
//!
//!     fn handle_read(&mut self, msg: Vec<u8>) -> Result<(), Self::Error> {
//!         // Reset heartbeat timer on any received message
//!         self.next_heartbeat = Some(Instant::now() + self.heartbeat_interval);
//!         Ok(())
//!     }
//!
//!     fn poll_read(&mut self) -> Option<Self::Rout> {
//!         None
//!     }
//!
//!     fn handle_write(&mut self, msg: Vec<u8>) -> Result<(), Self::Error> {
//!         self.pending_write = Some(msg);
//!         Ok(())
//!     }
//!
//!     fn poll_write(&mut self) -> Option<Self::Wout> {
//!         self.pending_write.take()
//!     }
//!
//!     fn handle_timeout(&mut self, now: Instant) -> Result<(), Self::Error> {
//!         // Send heartbeat
//!         self.pending_write = Some(b"HEARTBEAT".to_vec());
//!         self.next_heartbeat = Some(now + self.heartbeat_interval);
//!         Ok(())
//!     }
//!
//!     fn poll_timeout(&mut self) -> Option<Instant> {
//!         self.next_heartbeat
//!     }
//! }
//! ```
//!
//! ### Using tick counts (no_std friendly)
//!
//! ```rust
//! use sansio::Protocol;
//! # extern crate std;
//! # use std::collections::VecDeque;
//!
//! # #[derive(Debug)]
//! # struct MyError;
//! # impl std::fmt::Display for MyError {
//! #     fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
//! #         write!(f, "MyError")
//! #     }
//! # }
//! # impl std::error::Error for MyError {}
//! #
//! /// A protocol with timeout using tick counts (no_std friendly)
//! struct TickProtocol {
//!     next_timeout_tick: Option<u64>,
//!     timeout_interval: u64,
//!     messages: VecDeque<Vec<u8>>,
//! }
//!
//! impl TickProtocol {
//!     fn new(timeout_interval: u64) -> Self {
//!         Self {
//!             next_timeout_tick: None,
//!             timeout_interval,
//!             messages: VecDeque::new(),
//!         }
//!     }
//! }
//!
//! impl Protocol<Vec<u8>, Vec<u8>, ()> for TickProtocol {
//!     type Rout = Vec<u8>;
//!     type Wout = Vec<u8>;
//!     type Eout = ();
//!     type Error = MyError;
//!     type Time = u64;  // Using tick counts for embedded systems
//!
//!     fn handle_read(&mut self, msg: Vec<u8>) -> Result<(), Self::Error> {
//!         self.messages.push_back(msg);
//!         Ok(())
//!     }
//!
//!     fn poll_read(&mut self) -> Option<Self::Rout> {
//!         self.messages.pop_front()
//!     }
//!
//!     fn handle_write(&mut self, msg: Vec<u8>) -> Result<(), Self::Error> {
//!         self.messages.push_back(msg);
//!         Ok(())
//!     }
//!
//!     fn poll_write(&mut self) -> Option<Self::Wout> {
//!         self.messages.pop_front()
//!     }
//!
//!     fn handle_timeout(&mut self, current_tick: u64) -> Result<(), Self::Error> {
//!         // Handle timeout at current tick
//!         self.next_timeout_tick = Some(current_tick + self.timeout_interval);
//!         Ok(())
//!     }
//!
//!     fn poll_timeout(&mut self) -> Option<u64> {
//!         self.next_timeout_tick
//!     }
//! }
//! ```
//!
//! ## Event Handling Example
//!
//! Protocols can generate and handle custom events:
//!
//! ```rust
//! use sansio::Protocol;
//! # extern crate std;
//! # use std::collections::VecDeque;
//!
//! # #[derive(Debug)]
//! # struct MyError;
//! # impl std::fmt::Display for MyError {
//! #     fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
//! #         write!(f, "MyError")
//! #     }
//! # }
//! # impl std::error::Error for MyError {}
//! #
//! /// Custom event types
//! #[derive(Debug, PartialEq)]
//! enum ConnectionEvent {
//!     Connected,
//!     Disconnected,
//!     Error(String),
//! }
//!
//! /// Protocol that tracks connection state
//! struct ConnectionProtocol {
//!     connected: bool,
//!     event_queue: VecDeque<ConnectionEvent>,
//! }
//!
//! impl ConnectionProtocol {
//!     fn new() -> Self {
//!         Self {
//!             connected: false,
//!             event_queue: VecDeque::new(),
//!         }
//!     }
//! }
//!
//! impl Protocol<String, String, ConnectionEvent> for ConnectionProtocol {
//!     type Rout = String;
//!     type Wout = String;
//!     type Eout = ConnectionEvent;
//!     type Error = MyError;
//!     type Time = ();  // No timeout needed
//!
//!     fn handle_read(&mut self, msg: String) -> Result<(), Self::Error> {
//!         Ok(())
//!     }
//!
//!     fn poll_read(&mut self) -> Option<Self::Rout> {
//!         None
//!     }
//!
//!     fn handle_write(&mut self, msg: String) -> Result<(), Self::Error> {
//!         Ok(())
//!     }
//!
//!     fn poll_write(&mut self) -> Option<Self::Wout> {
//!         None
//!     }
//!
//!     fn handle_event(&mut self, evt: ConnectionEvent) -> Result<(), Self::Error> {
//!         match evt {
//!             ConnectionEvent::Connected => {
//!                 self.connected = true;
//!                 self.event_queue.push_back(ConnectionEvent::Connected);
//!             }
//!             ConnectionEvent::Disconnected => {
//!                 self.connected = false;
//!                 self.event_queue.push_back(ConnectionEvent::Disconnected);
//!             }
//!             ConnectionEvent::Error(msg) => {
//!                 self.event_queue.push_back(ConnectionEvent::Error(msg));
//!             }
//!         }
//!         Ok(())
//!     }
//!
//!     fn poll_event(&mut self) -> Option<Self::Eout> {
//!         self.event_queue.pop_front()
//!     }
//! }
//! ```
//!
//! ## Protocol Composition
//!
//! Protocols can be layered and composed. Here's a simple example of wrapping one protocol
//! with another:
//!
//! ```rust
//! use sansio::Protocol;
//!
//! # #[derive(Debug)]
//! # struct MyError;
//! # impl std::fmt::Display for MyError {
//! #     fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
//! #         write!(f, "MyError")
//! #     }
//! # }
//! # impl std::error::Error for MyError {}
//! #
//! /// A protocol wrapper that logs all messages
//! struct LoggingWrapper<P> {
//!     inner: P,
//! }
//!
//! impl<P> LoggingWrapper<P> {
//!     fn new(inner: P) -> Self {
//!         Self { inner }
//!     }
//! }
//!
//! impl<P, Rin, Win, Ein> Protocol<Rin, Win, Ein> for LoggingWrapper<P>
//! where
//!     P: Protocol<Rin, Win, Ein>,
//!     Rin: std::fmt::Debug,
//!     Win: std::fmt::Debug,
//! {
//!     type Rout = P::Rout;
//!     type Wout = P::Wout;
//!     type Eout = P::Eout;
//!     type Error = P::Error;
//!     type Time = P::Time;  // Inherit time type from wrapped protocol
//!
//!     fn handle_read(&mut self, msg: Rin) -> Result<(), Self::Error> {
//!         println!("READ: {:?}", msg);
//!         self.inner.handle_read(msg)
//!     }
//!
//!     fn poll_read(&mut self) -> Option<Self::Rout> {
//!         self.inner.poll_read()
//!     }
//!
//!     fn handle_write(&mut self, msg: Win) -> Result<(), Self::Error> {
//!         println!("WRITE: {:?}", msg);
//!         self.inner.handle_write(msg)
//!     }
//!
//!     fn poll_write(&mut self) -> Option<Self::Wout> {
//!         self.inner.poll_write()
//!     }
//! }
//! ```
//!
//! ## Testing Protocols
//!
//! Sans-IO protocols are trivial to test since they don't involve any I/O:
//!
//! ```rust
//! # use sansio::Protocol;
//! # extern crate std;
//! # use std::collections::VecDeque;
//! # #[derive(Debug)]
//! # struct MyError;
//! # impl std::fmt::Display for MyError {
//! #     fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
//! #         write!(f, "MyError")
//! #     }
//! # }
//! # impl std::error::Error for MyError {}
//! # struct UppercaseProtocol { routs: VecDeque<String>, wouts: VecDeque<String> }
//! # impl UppercaseProtocol { fn new() -> Self { Self { routs: VecDeque::new(), wouts: VecDeque::new() } } }
//! # impl Protocol<String, String, ()> for UppercaseProtocol {
//! #     type Rout = String; type Wout = String; type Eout = (); type Error = MyError; type Time = ();
//! #     fn handle_read(&mut self, msg: String) -> Result<(), Self::Error> {
//! #         self.routs.push_back(msg.to_uppercase()); Ok(())
//! #     }
//! #     fn poll_read(&mut self) -> Option<Self::Rout> { self.routs.pop_front() }
//! #     fn handle_write(&mut self, msg: String) -> Result<(), Self::Error> {
//! #         self.wouts.push_back(msg); Ok(())
//! #     }
//! #     fn poll_write(&mut self) -> Option<Self::Wout> { self.wouts.pop_front() }
//! # }
//! #[test]
//! fn test_protocol() {
//!     let mut protocol = UppercaseProtocol::new();
//!
//!     // Test single message
//!     protocol.handle_read("hello".to_string()).unwrap();
//!     assert_eq!(protocol.poll_read(), Some("HELLO".to_string()));
//!
//!     // Test multiple messages
//!     protocol.handle_read("foo".to_string()).unwrap();
//!     protocol.handle_read("bar".to_string()).unwrap();
//!     assert_eq!(protocol.poll_read(), Some("FOO".to_string()));
//!     assert_eq!(protocol.poll_read(), Some("BAR".to_string()));
//!     assert_eq!(protocol.poll_read(), None);
//! }
//! ```

#![no_std]
#![doc(
    html_logo_url = "https://raw.githubusercontent.com/webrtc-rs/sansio/master/sansio-white.png"
)]
#![warn(rust_2018_idioms)]
#![allow(dead_code)]
#![warn(missing_docs)]

extern crate alloc;

use alloc::boxed::Box;

/// A Sans-IO protocol abstraction.
///
/// The `Protocol` trait provides a simplified interface for building network protocols
/// that are fully decoupled from I/O operations.
///
/// # Type Parameters
///
/// - `Rin`: Input read message type
/// - `Win`: Input write message type
/// - `Ein`: Input event type
///
/// # Design Pattern
///
/// This trait follows a push-pull pattern:
/// 1. **Push** data/events into the protocol using `handle_*` methods
/// 2. **Pull** results from the protocol using `poll_*` methods
///
/// This allows the protocol logic to be completely independent of I/O,
/// making it easy to test and reuse in different contexts.
///
/// # Example
///
/// See the [module-level documentation](index.html) for a complete example.
pub trait Protocol<Rin, Win, Ein> {
    /// Output read message type
    ///
    /// This is the type of messages produced after processing inbound data.
    type Rout;

    /// Output write message type
    ///
    /// This is the type of messages produced for outbound transmission.
    type Wout;

    /// Output event type
    ///
    /// Custom events that the protocol may generate.
    type Eout;

    /// Error type for protocol operations
    type Error;

    /// Time/Instant type for timeout handling
    ///
    /// This type represents time instants for timeout handling.
    ///
    /// - With `std`: Typically `std::time::Instant`
    /// - Without `std`: Can be `u64` (ticks), `i64` (milliseconds), or any custom type
    ///
    /// # Examples
    ///
    /// ```ignore
    /// // With std
    /// type Time = std::time::Instant;
    ///
    /// // Without std (using tick counts)
    /// type Time = u64;
    ///
    /// // Without std (using milliseconds since epoch)
    /// type Time = i64;
    /// ```
    type Time;

    /// Handle an incoming read message.
    ///
    /// Processes an inbound message. The result can be polled later via [`poll_read`].
    ///
    /// # Parameters
    ///
    /// - `msg`: The incoming message to process
    ///
    /// # Returns
    ///
    /// - `Ok(())` if the message was successfully queued for processing
    /// - `Err(Self::Error)` if processing failed
    ///
    /// # Example
    ///
    /// ```ignore
    /// protocol.handle_read(incoming_data)?;
    /// // Later...
    /// if let Some(processed) = protocol.poll_read() {
    ///     // Handle processed data
    /// }
    /// ```
    ///
    /// [`poll_read`]: Protocol::poll_read
    fn handle_read(&mut self, msg: Rin) -> Result<(), Self::Error>;

    /// Poll for a processed read message.
    ///
    /// Returns the next processed inbound message, if any.
    /// Call this after [`handle_read`] to retrieve processed results.
    ///
    /// # Returns
    ///
    /// - `Some(Rout)` if a processed message is available
    /// - `None` if no processed messages are ready
    ///
    /// [`handle_read`]: Protocol::handle_read
    fn poll_read(&mut self) -> Option<Self::Rout>;

    /// Handle an outgoing write message.
    ///
    /// Processes an outbound message for transmission. The result can be polled
    /// later via [`poll_write`].
    ///
    /// # Parameters
    ///
    /// - `msg`: The outgoing message to process
    ///
    /// # Returns
    ///
    /// - `Ok(())` if the message was successfully queued
    /// - `Err(Self::Error)` if processing failed
    ///
    /// [`poll_write`]: Protocol::poll_write
    fn handle_write(&mut self, msg: Win) -> Result<(), Self::Error>;

    /// Poll for a processed write message.
    ///
    /// Returns the next processed outbound message, if any.
    /// Call this after [`handle_write`] to retrieve messages ready for transmission.
    ///
    /// # Returns
    ///
    /// - `Some(Wout)` if a message is ready to send
    /// - `None` if no messages are ready
    ///
    /// [`handle_write`]: Protocol::handle_write
    fn poll_write(&mut self) -> Option<Self::Wout>;

    /// Handle a custom event.
    ///
    /// Process protocol-specific events. The default implementation does nothing.
    ///
    /// # Parameters
    ///
    /// - `_evt`: The event to handle
    ///
    /// # Returns
    ///
    /// - `Ok(())` by default
    /// - Override to provide custom event handling logic
    fn handle_event(&mut self, _evt: Ein) -> Result<(), Self::Error> {
        Ok(())
    }

    /// Poll for a generated event.
    ///
    /// Returns the next event generated by the protocol, if any.
    ///
    /// # Returns
    ///
    /// - `Some(Eout)` if an event was generated
    /// - `None` by default (override to implement custom events)
    fn poll_event(&mut self) -> Option<Self::Eout> {
        None
    }

    /// Handle a timeout event.
    ///
    /// Called periodically to allow the protocol to perform time-based operations
    /// (e.g., heartbeats, timeouts, retransmissions).
    ///
    /// # Parameters
    ///
    /// - `_now`: The current time value (type specified by [`Self::Time`])
    ///
    /// # Returns
    ///
    /// - `Ok(())` by default
    /// - Override to implement time-based protocol logic
    ///
    /// # Examples
    ///
    /// With `std`:
    /// ```ignore
    /// fn handle_timeout(&mut self, now: std::time::Instant) -> Result<(), Self::Error> {
    ///     // Check for expired connections, send heartbeats, etc.
    ///     Ok(())
    /// }
    /// ```
    ///
    /// Without `std` (using tick counts):
    /// ```ignore
    /// fn handle_timeout(&mut self, now: u64) -> Result<(), Self::Error> {
    ///     // now is in system ticks
    ///     Ok(())
    /// }
    /// ```
    ///
    /// [`Self::Time`]: Protocol::Time
    fn handle_timeout(&mut self, _now: Self::Time) -> Result<(), Self::Error> {
        Ok(())
    }

    /// Poll for the next timeout deadline.
    ///
    /// Returns when the protocol next wants to be called via [`handle_timeout`].
    ///
    /// # Returns
    ///
    /// - `Some(Time)` if the protocol has a pending timeout
    /// - `None` if no timeout is needed (default)
    ///
    /// # Examples
    ///
    /// With `std`:
    /// ```ignore
    /// fn poll_timeout(&mut self) -> Option<std::time::Instant> {
    ///     self.next_deadline
    /// }
    /// ```
    ///
    /// Without `std` (using tick counts):
    /// ```ignore
    /// fn poll_timeout(&mut self) -> Option<u64> {
    ///     self.next_tick
    /// }
    /// ```
    ///
    /// [`handle_timeout`]: Protocol::handle_timeout
    fn poll_timeout(&mut self) -> Option<Self::Time> {
        None
    }

    /// Close the protocol.
    ///
    /// Called when the protocol should perform cleanup and release resources.
    ///
    /// # Returns
    ///
    /// - `Ok(())` by default
    /// - Override to implement cleanup logic
    fn close(&mut self) -> Result<(), Self::Error> {
        Ok(())
    }
}

// ========================================
// Blanket Implementations
// ========================================

/// Blanket implementation for mutable references.
///
/// This allows protocols to be used through mutable references without
/// requiring explicit dereferencing.
impl<P, Rin, Win, Ein> Protocol<Rin, Win, Ein> for &mut P
where
    P: Protocol<Rin, Win, Ein> + ?Sized,
{
    type Rout = P::Rout;
    type Wout = P::Wout;
    type Eout = P::Eout;
    type Error = P::Error;
    type Time = P::Time;

    fn handle_read(&mut self, msg: Rin) -> Result<(), P::Error> {
        (**self).handle_read(msg)
    }

    fn poll_read(&mut self) -> Option<P::Rout> {
        (**self).poll_read()
    }

    fn handle_write(&mut self, msg: Win) -> Result<(), P::Error> {
        (**self).handle_write(msg)
    }

    fn poll_write(&mut self) -> Option<P::Wout> {
        (**self).poll_write()
    }

    fn handle_event(&mut self, evt: Ein) -> Result<(), P::Error> {
        (**self).handle_event(evt)
    }

    fn poll_event(&mut self) -> Option<P::Eout> {
        (**self).poll_event()
    }

    fn handle_timeout(&mut self, now: P::Time) -> Result<(), P::Error> {
        (**self).handle_timeout(now)
    }

    fn poll_timeout(&mut self) -> Option<P::Time> {
        (**self).poll_timeout()
    }

    fn close(&mut self) -> Result<(), P::Error> {
        (**self).close()
    }
}

/// Blanket implementation for boxed protocols.
///
/// This allows protocols to be used through `Box<dyn Protocol>` for dynamic dispatch.
impl<P, Rin, Win, Ein> Protocol<Rin, Win, Ein> for Box<P>
where
    P: Protocol<Rin, Win, Ein> + ?Sized,
{
    type Rout = P::Rout;
    type Wout = P::Wout;
    type Eout = P::Eout;
    type Error = P::Error;
    type Time = P::Time;

    fn handle_read(&mut self, msg: Rin) -> Result<(), P::Error> {
        (**self).handle_read(msg)
    }

    fn poll_read(&mut self) -> Option<P::Rout> {
        (**self).poll_read()
    }

    fn handle_write(&mut self, msg: Win) -> Result<(), P::Error> {
        (**self).handle_write(msg)
    }

    fn poll_write(&mut self) -> Option<P::Wout> {
        (**self).poll_write()
    }

    fn handle_event(&mut self, evt: Ein) -> Result<(), P::Error> {
        (**self).handle_event(evt)
    }

    fn poll_event(&mut self) -> Option<P::Eout> {
        (**self).poll_event()
    }

    fn handle_timeout(&mut self, now: P::Time) -> Result<(), P::Error> {
        (**self).handle_timeout(now)
    }

    fn poll_timeout(&mut self) -> Option<P::Time> {
        (**self).poll_timeout()
    }

    fn close(&mut self) -> Result<(), P::Error> {
        (**self).close()
    }
}
